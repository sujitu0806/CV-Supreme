{
  "version": 3,
  "sources": ["../../@overshoot/sdk/src/client/errors.ts", "../../@overshoot/sdk/src/client/client.ts", "../../@overshoot/sdk/src/client/RealtimeVision.ts"],
  "sourcesContent": ["export class ApiError extends Error {\n  readonly statusCode?: number;\n  readonly requestId?: string;\n  readonly details?: any;\n\n  constructor(\n    message: string,\n    statusCode?: number,\n    requestId?: string,\n    details?: any,\n  ) {\n    super(message);\n    this.name = \"ApiError\";\n    this.statusCode = statusCode;\n    this.requestId = requestId;\n    this.details = details;\n  }\n}\n\nexport class UnauthorizedError extends ApiError {\n  constructor(message: string, requestId?: string) {\n    super(message, 401, requestId);\n    this.name = \"UnauthorizedError\";\n  }\n}\n\nexport class ValidationError extends ApiError {\n  constructor(message: string, requestId?: string, details?: any) {\n    super(message, 422, requestId, details);\n    this.name = \"ValidationError\";\n  }\n}\n\nexport class NotFoundError extends ApiError {\n  constructor(message: string, requestId?: string) {\n    super(message, 404, requestId);\n    this.name = \"NotFoundError\";\n  }\n}\n\nexport class NetworkError extends ApiError {\n  readonly cause?: Error;\n\n  constructor(message: string, cause?: Error) {\n    super(message);\n    this.name = \"NetworkError\";\n    this.cause = cause;\n  }\n}\n\nexport class ServerError extends ApiError {\n  constructor(message: string, requestId?: string, details?: any) {\n    super(message, 500, requestId, details);\n    this.name = \"ServerError\";\n  }\n}\n", "import type {\n  StreamCreateRequest,\n  StreamCreateResponse,\n  KeepaliveResponse,\n  StreamConfigResponse,\n  ErrorResponse,\n} from \"./types\";\nimport {\n  ApiError,\n  ValidationError,\n  NotFoundError,\n  NetworkError,\n  ServerError,\n  UnauthorizedError,\n} from \"./errors\";\n\ntype ClientConfig = {\n  baseUrl: string;\n  apiKey: string;\n};\n\nexport class StreamClient {\n  private baseUrl: string;\n  private apiKey: string;\n\n  constructor(config: ClientConfig) {\n    if (!config.apiKey || typeof config.apiKey !== \"string\") {\n      throw new Error(\"apiKey is required and must be a string\");\n    }\n\n    this.baseUrl = config.baseUrl;\n    this.apiKey = config.apiKey;\n  }\n\n  private async request<T>(\n    path: string,\n    options: RequestInit = {},\n  ): Promise<T> {\n    const url = `${this.baseUrl}${path}`;\n    const controller = new AbortController();\n\n    try {\n      const response = await fetch(url, {\n        ...options,\n        signal: controller.signal,\n        credentials: \"include\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${this.apiKey}`,\n          ...options.headers,\n        },\n      });\n\n      if (!response.ok) {\n        const errorData: ErrorResponse = await response.json().catch(() => ({\n          error: \"unknown_error\",\n          message: response.statusText,\n        }));\n\n        const message = errorData.message || errorData.error;\n\n        if (response.status === 401) {\n          throw new UnauthorizedError(\n            message || \"Invalid or revoked API key\",\n            errorData.request_id,\n          );\n        }\n        if (response.status === 422 || response.status === 400) {\n          throw new ValidationError(\n            message,\n            errorData.request_id,\n            errorData.details,\n          );\n        }\n        if (response.status === 404) {\n          throw new NotFoundError(message, errorData.request_id);\n        }\n        if (response.status >= 500) {\n          throw new ServerError(\n            message,\n            errorData.request_id,\n            errorData.details,\n          );\n        }\n\n        throw new ApiError(\n          message,\n          response.status,\n          errorData.request_id,\n          errorData.details,\n        );\n      }\n\n      return await response.json();\n    } catch (error) {\n      if (error instanceof ApiError) {\n        throw error;\n      }\n\n      if (error instanceof Error) {\n        throw new NetworkError(`Network error: ${error.message}`, error);\n      }\n\n      throw new NetworkError(\"Unknown network error\");\n    }\n  }\n  async createStream(\n    request: StreamCreateRequest,\n  ): Promise<StreamCreateResponse> {\n    return this.request<StreamCreateResponse>(\"/streams\", {\n      method: \"POST\",\n      body: JSON.stringify(request),\n    });\n  }\n\n  async renewLease(streamId: string): Promise<KeepaliveResponse> {\n    return this.request<KeepaliveResponse>(`/streams/${streamId}/keepalive`, {\n      method: \"POST\",\n    });\n  }\n\n  async updatePrompt(\n    streamId: string,\n    prompt: string,\n  ): Promise<StreamConfigResponse> {\n    return this.request<StreamConfigResponse>(\n      `/streams/${streamId}/config/prompt`,\n      {\n        method: \"PATCH\",\n        body: JSON.stringify({ prompt }),\n      },\n    );\n  }\n\n  connectWebSocket(streamId: string): WebSocket {\n    const wsUrl = this.baseUrl\n      .replace(\"http://\", \"ws://\")\n      .replace(\"https://\", \"wss://\");\n    return new WebSocket(`${wsUrl}/ws/streams/${streamId}`);\n  }\n\n  /**\n   * Health check endpoint (for testing, uses internal port if available)\n   * Note: This endpoint may not be available via the main API\n   */\n  async healthCheck(): Promise<string> {\n    const url = `${this.baseUrl}/healthz`;\n    const response = await fetch(url, {\n      credentials: \"include\",\n    });\n    return response.text();\n  }\n}\n", "import { StreamClient } from \"./client\";\n\nimport {\n  type StreamInferenceResult,\n  type StreamProcessingConfig,\n  type StreamSource,\n} from \"./types\";\n\n/**\n * Default configuration values for RealtimeVision\n */\nconst DEFAULTS = {\n  BACKEND: \"overshoot\" as const,\n  MODEL: \"Qwen/Qwen3-VL-30B-A3B-Instruct\",\n  SOURCE: { type: \"camera\", cameraFacing: \"environment\" } as const,\n  SAMPLING_RATIO: 0.1,\n  CLIP_LENGTH_SECONDS: 1.0,\n  DELAY_SECONDS: 1.0,\n  FALLBACK_FPS: 30,\n  ICE_SERVERS: [\n    {\n      urls: \"turn:turn.overshoot.ai:3478?transport=udp\",\n      username: \"1769538895:c66a907c-61f4-4ec2-93a6-9d6b932776bb\",\n      credential: \"Fu9L4CwyYZvsOLc+23psVAo3i/Y=\",\n    },\n    {\n      urls: \"turn:turn.overshoot.ai:3478?transport=tcp\",\n      username: \"1769538895:c66a907c-61f4-4ec2-93a6-9d6b932776bb\",\n      credential: \"Fu9L4CwyYZvsOLc+23psVAo3i/Y=\",\n    },\n    {\n      urls: \"turns:turn.overshoot.ai:443?transport=udp\",\n      username: \"1769538895:c66a907c-61f4-4ec2-93a6-9d6b932776bb\",\n      credential: \"Fu9L4CwyYZvsOLc+23psVAo3i/Y=\",\n    },\n    {\n      urls: \"turns:turn.overshoot.ai:443?transport=tcp\",\n      username: \"1769538895:c66a907c-61f4-4ec2-93a6-9d6b932776bb\",\n      credential: \"Fu9L4CwyYZvsOLc+23psVAo3i/Y=\",\n    },\n  ] as RTCIceServer[],\n} as const;\n\n/**\n * Validation constraints\n */\nconst CONSTRAINTS = {\n  SAMPLING_RATIO: { min: 0, max: 1 },\n  FPS: { min: 1, max: 120 },\n  CLIP_LENGTH_SECONDS: { min: 0.1, max: 60 },\n  DELAY_SECONDS: { min: 0, max: 60 },\n} as const;\n\n/**\n * Logger utility for controlled logging\n */\nclass Logger {\n  private debugEnabled: boolean;\n\n  constructor(debugEnabled: boolean = false) {\n    this.debugEnabled = debugEnabled;\n  }\n\n  debug(...args: any[]): void {\n    if (this.debugEnabled) {\n      console.log(\"[RealtimeVision Debug]\", ...args);\n    }\n  }\n\n  info(...args: any[]): void {\n    console.log(\"[RealtimeVision]\", ...args);\n  }\n\n  warn(...args: any[]): void {\n    console.warn(\"[RealtimeVision]\", ...args);\n  }\n\n  error(...args: any[]): void {\n    console.error(\"[RealtimeVision]\", ...args);\n  }\n}\n\nexport interface RealtimeVisionConfig {\n  /**\n   * Base URL for the API (e.g., \"https://api.example.com\")\n   */\n  apiUrl: string;\n\n  /**\n   * API key for authentication\n   * Required for all API requests\n   */\n  apiKey: string;\n\n  /**\n   * The prompt/task to run on window segments of the stream.\n   * This runs continuously (at a defined window interval).\n   *\n   * Examples:\n   * - \"Read any visible text\"\n   * - \"Detect objects and return as JSON array\"\n   * - \"Describe facial expression\"\n   */\n  prompt: string;\n\n  /**\n   * Video source configuration\n   * Defaults to camera with environment facing if not specified\n   */\n  source?: StreamSource;\n\n  /**\n   * Model backend to use\n   */\n  backend?: \"overshoot\";\n\n  /**\n   * Model name to use for inference\n   */\n  model?: string;\n\n  /**\n   * Optional JSON schema for structured output\n   */\n  outputSchema?: Record<string, any>;\n\n  /**\n   * Called when a new inference result arrives (~1 per second)\n   */\n  onResult: (result: StreamInferenceResult) => void;\n\n  /**\n   * Called when an error occurs\n   */\n  onError?: (error: Error) => void;\n\n  /**\n   * Custom processing configuration\n   * All fields are optional and will use defaults if not provided\n   */\n  processing?: {\n    /**\n     * Sampling ratio (0-1). Controls what fraction of frames are processed.\n     */\n    sampling_ratio?: number;\n    /**\n     * Frames per second (1-120)\n     */\n    fps?: number;\n    /**\n     * Clip length in seconds (0.1-60)\n     */\n    clip_length_seconds?: number;\n    /**\n     * Delay in seconds (0-60)\n     */\n    delay_seconds?: number;\n  };\n\n  /**\n   * ICE servers for WebRTC connection\n   * If not provided, uses default TURN servers\n   */\n  iceServers?: RTCIceServer[];\n\n  /**\n   * Enable debug logging\n   * @default false\n   */\n  debug?: boolean;\n}\n\nclass ValidationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"ValidationError\";\n  }\n}\n\nexport class RealtimeVision {\n  private config: RealtimeVisionConfig;\n  private client: StreamClient;\n  private logger: Logger;\n\n  private mediaStream: MediaStream | null = null;\n  private peerConnection: RTCPeerConnection | null = null;\n  private webSocket: WebSocket | null = null;\n  private streamId: string | null = null;\n  private keepaliveInterval: number | null = null;\n  private videoElement: HTMLVideoElement | null = null;\n  private canvasElement: HTMLCanvasElement | null = null;\n  private canvasAnimationFrameId: number | null = null;\n\n  private isRunning = false;\n\n  constructor(config: RealtimeVisionConfig) {\n    this.validateConfig(config);\n    this.config = config;\n    this.logger = new Logger(config.debug ?? false);\n    this.client = new StreamClient({\n      baseUrl: config.apiUrl,\n      apiKey: config.apiKey,\n    });\n  }\n\n  /**\n   * Validate configuration values\n   */\n  private validateConfig(config: RealtimeVisionConfig): void {\n    if (!config.apiUrl || typeof config.apiUrl !== \"string\") {\n      throw new ValidationError(\"apiUrl is required and must be a string\");\n    }\n\n    if (!config.apiKey || typeof config.apiKey !== \"string\") {\n      throw new ValidationError(\"apiKey is required and must be a string\");\n    }\n\n    if (!config.prompt || typeof config.prompt !== \"string\") {\n      throw new ValidationError(\"prompt is required and must be a string\");\n    }\n\n    if (config.source) {\n      if (config.source.type === \"camera\") {\n        if (\n          config.source.cameraFacing !== \"user\" &&\n          config.source.cameraFacing !== \"environment\"\n        ) {\n          throw new ValidationError(\n            'cameraFacing must be \"user\" or \"environment\"',\n          );\n        }\n      } else if (config.source.type === \"video\") {\n        if (!(config.source.file instanceof File)) {\n          throw new ValidationError(\"video source must provide a File object\");\n        }\n      } else {\n        throw new ValidationError('source.type must be \"camera\" or \"video\"');\n      }\n    }\n\n    if (config.processing?.sampling_ratio !== undefined) {\n      const ratio = config.processing.sampling_ratio;\n      if (\n        ratio < CONSTRAINTS.SAMPLING_RATIO.min ||\n        ratio > CONSTRAINTS.SAMPLING_RATIO.max\n      ) {\n        throw new ValidationError(\n          `sampling_ratio must be between ${CONSTRAINTS.SAMPLING_RATIO.min} and ${CONSTRAINTS.SAMPLING_RATIO.max}`,\n        );\n      }\n    }\n\n    if (config.processing?.fps !== undefined) {\n      const fps = config.processing.fps;\n      if (fps < CONSTRAINTS.FPS.min || fps > CONSTRAINTS.FPS.max) {\n        throw new ValidationError(\n          `fps must be between ${CONSTRAINTS.FPS.min} and ${CONSTRAINTS.FPS.max}`,\n        );\n      }\n    }\n\n    if (config.processing?.clip_length_seconds !== undefined) {\n      const clip = config.processing.clip_length_seconds;\n      if (\n        clip < CONSTRAINTS.CLIP_LENGTH_SECONDS.min ||\n        clip > CONSTRAINTS.CLIP_LENGTH_SECONDS.max\n      ) {\n        throw new ValidationError(\n          `clip_length_seconds must be between ${CONSTRAINTS.CLIP_LENGTH_SECONDS.min} and ${CONSTRAINTS.CLIP_LENGTH_SECONDS.max}`,\n        );\n      }\n    }\n\n    if (config.processing?.delay_seconds !== undefined) {\n      const delay = config.processing.delay_seconds;\n      if (\n        delay < CONSTRAINTS.DELAY_SECONDS.min ||\n        delay > CONSTRAINTS.DELAY_SECONDS.max\n      ) {\n        throw new ValidationError(\n          `delay_seconds must be between ${CONSTRAINTS.DELAY_SECONDS.min} and ${CONSTRAINTS.DELAY_SECONDS.max}`,\n        );\n      }\n    }\n  }\n\n  /**\n   * Create media stream from the configured source\n   */\n  private async createMediaStream(source: StreamSource): Promise<MediaStream> {\n    this.logger.debug(\"Creating media stream from source:\", source.type);\n\n    switch (source.type) {\n      case \"camera\":\n        return await navigator.mediaDevices.getUserMedia({\n          video: { facingMode: { ideal: source.cameraFacing } },\n          audio: false,\n        });\n\n      case \"video\":\n        const video = document.createElement(\"video\");\n        video.src = URL.createObjectURL(source.file);\n        video.muted = true;\n        video.loop = true;\n        video.playsInline = true;\n\n        this.logger.debug(\"Loading video file:\", source.file.name);\n\n        // Wait for video to be ready\n        await new Promise<void>((resolve, reject) => {\n          const timeout = setTimeout(() => {\n            reject(new Error(\"Video loading timeout after 10 seconds\"));\n          }, 10000);\n\n          video.onloadedmetadata = () => {\n            clearTimeout(timeout);\n            this.logger.debug(\"Video metadata loaded\");\n            resolve();\n          };\n\n          video.onerror = (e) => {\n            clearTimeout(timeout);\n            this.logger.error(\"Video loading error:\", e);\n            reject(new Error(\"Failed to load video file\"));\n          };\n\n          if (video.readyState >= 1) {\n            clearTimeout(timeout);\n            resolve();\n          }\n        });\n\n        await video.play();\n        this.logger.debug(\"Video playback started\");\n\n        let stream: MediaStream;\n\n        // Check if captureStream is supported (Chrome, Firefox)\n        if (typeof video.captureStream === \"function\") {\n          this.logger.debug(\"Using native video.captureStream()\");\n          stream = video.captureStream();\n        } else {\n          // Safari fallback: use canvas to capture the video stream\n          this.logger.debug(\n            \"captureStream not supported, using canvas fallback for Safari\",\n          );\n\n          const canvas = document.createElement(\"canvas\");\n          canvas.width = video.videoWidth || 640;\n          canvas.height = video.videoHeight || 480;\n          const ctx = canvas.getContext(\"2d\");\n\n          if (!ctx) {\n            throw new Error(\"Failed to get canvas 2D context\");\n          }\n\n          // Draw video frames to canvas continuously\n          const drawFrame = () => {\n            if (!video.paused && !video.ended) {\n              ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n              this.canvasAnimationFrameId = requestAnimationFrame(drawFrame);\n            }\n          };\n          drawFrame();\n\n          // Capture stream from canvas (30 fps)\n          stream = canvas.captureStream(30);\n          this.canvasElement = canvas;\n        }\n\n        if (!stream) {\n          throw new Error(\"Failed to capture video stream\");\n        }\n\n        const videoTracks = stream.getVideoTracks();\n        if (videoTracks.length === 0) {\n          throw new Error(\"Video stream has no video tracks\");\n        }\n\n        this.videoElement = video;\n        return stream;\n\n      default:\n        throw new Error(`Unknown source type: ${(source as any).type}`);\n    }\n  }\n\n  /**\n   * Get FPS from media stream\n   */\n  private async getStreamFps(\n    stream: MediaStream | null,\n    source: StreamSource,\n  ): Promise<number> {\n    if (!stream) {\n      this.logger.warn(\"Stream is null, using fallback FPS\");\n      return DEFAULTS.FALLBACK_FPS;\n    }\n\n    const videoTracks = stream.getVideoTracks();\n    if (!videoTracks || videoTracks.length === 0) {\n      this.logger.warn(\"No video tracks found, using fallback FPS\");\n      return DEFAULTS.FALLBACK_FPS;\n    }\n\n    const videoTrack = videoTracks[0];\n    if (!videoTrack) {\n      this.logger.warn(\"First video track is null, using fallback FPS\");\n      return DEFAULTS.FALLBACK_FPS;\n    }\n\n    // For camera sources, get FPS from track settings\n    if (source.type === \"camera\") {\n      const settings = videoTrack.getSettings();\n      const fps = settings.frameRate ?? DEFAULTS.FALLBACK_FPS;\n      this.logger.debug(\"Detected camera FPS:\", fps);\n      return fps;\n    }\n\n    // For video file sources, try to get FPS from video element\n    if (source.type === \"video\" && this.videoElement) {\n      await new Promise<void>((resolve, reject) => {\n        if (this.videoElement!.readyState >= 1) {\n          resolve();\n        } else {\n          this.videoElement!.onloadedmetadata = () => resolve();\n          this.videoElement!.onerror = () =>\n            reject(new Error(\"Failed to load video metadata\"));\n        }\n      });\n\n      // For video files, use fallback FPS or user-specified config\n      this.logger.debug(\"Using fallback FPS for video file\");\n      return DEFAULTS.FALLBACK_FPS;\n    }\n\n    return DEFAULTS.FALLBACK_FPS;\n  }\n\n  /**\n   * Get processing configuration with defaults applied\n   */\n  private getProcessingConfig(detectedFps: number): StreamProcessingConfig {\n    const userProcessing = this.config.processing || {};\n\n    return {\n      sampling_ratio: userProcessing.sampling_ratio ?? DEFAULTS.SAMPLING_RATIO,\n      fps: userProcessing.fps ?? detectedFps,\n      clip_length_seconds:\n        userProcessing.clip_length_seconds ?? DEFAULTS.CLIP_LENGTH_SECONDS,\n      delay_seconds: userProcessing.delay_seconds ?? DEFAULTS.DELAY_SECONDS,\n    };\n  }\n\n  /**\n   * Get the effective source configuration\n   */\n  private getSource(): StreamSource {\n    return this.config.source ?? DEFAULTS.SOURCE;\n  }\n\n  /**\n   * Start the vision stream\n   */\n  async start(): Promise<void> {\n    if (this.isRunning) {\n      throw new Error(\"Vision stream already running\");\n    }\n\n    try {\n      const source = this.getSource();\n      this.logger.debug(\"Starting stream with source type:\", source.type);\n\n      if (source.type === \"video\") {\n        this.logger.debug(\"Video file:\", {\n          name: source.file.name,\n          size: source.file.size,\n          type: source.file.type,\n        });\n\n        if (!source.file || !(source.file instanceof File)) {\n          throw new Error(\"Invalid video file\");\n        }\n      }\n\n      // Create media stream\n      this.mediaStream = await this.createMediaStream(source);\n      const videoTrack = this.mediaStream.getVideoTracks()[0];\n      if (!videoTrack) {\n        throw new Error(\"No video track available\");\n      }\n\n      // Get FPS for the stream\n      const detectedFps = await this.getStreamFps(this.mediaStream, source);\n\n      // Set up WebRTC peer connection\n      const iceServers = this.config.iceServers ?? DEFAULTS.ICE_SERVERS;\n      this.logger.debug(\"Creating peer connection with ICE servers\");\n      this.peerConnection = new RTCPeerConnection({ iceServers });\n\n      // Set up ICE logging\n      this.peerConnection.onicecandidate = (event) => {\n        if (event.candidate) {\n          this.logger.debug(\"ICE candidate:\", {\n            type: event.candidate.type,\n            protocol: event.candidate.protocol,\n          });\n        } else {\n          this.logger.debug(\"ICE gathering complete\");\n        }\n      };\n\n      this.peerConnection.oniceconnectionstatechange = () => {\n        this.logger.debug(\n          \"ICE connection state:\",\n          this.peerConnection?.iceConnectionState,\n        );\n      };\n\n      this.peerConnection.addTrack(videoTrack, this.mediaStream);\n\n      // Create and set local offer\n      const offer = await this.peerConnection.createOffer();\n      await this.peerConnection.setLocalDescription(offer);\n\n      if (!this.peerConnection.localDescription) {\n        throw new Error(\"Failed to create local description\");\n      }\n\n      // Create stream on server\n      this.logger.debug(\"Creating stream on server\");\n      const response = await this.client.createStream({\n        webrtc: {\n          type: \"offer\",\n          sdp: this.peerConnection.localDescription.sdp,\n        },\n        processing: this.getProcessingConfig(detectedFps),\n        inference: {\n          prompt: this.config.prompt,\n          backend: this.config.backend ?? DEFAULTS.BACKEND,\n          model: this.config.model ?? DEFAULTS.MODEL,\n          output_schema_json: this.config.outputSchema,\n        },\n      });\n\n      this.logger.debug(\"Backend response received:\", {\n        stream_id: response.stream_id,\n        has_turn_servers: !!response.turn_servers,\n      });\n\n      // Set remote description\n      await this.peerConnection.setRemoteDescription(response.webrtc);\n\n      this.streamId = response.stream_id;\n      this.logger.info(\"Stream started:\", this.streamId);\n\n      // Set up keepalive\n      this.setupKeepalive(response.lease?.ttl_seconds);\n\n      // Connect WebSocket for results\n      this.setupWebSocket(response.stream_id);\n\n      this.isRunning = true;\n    } catch (error) {\n      await this.handleFatalError(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Set up keepalive interval with error handling\n   */\n  private setupKeepalive(ttlSeconds: number | undefined): void {\n    if (!ttlSeconds) {\n      return;\n    }\n\n    const intervalMs = (ttlSeconds / 2) * 1000;\n    this.logger.debug(\"Setting up keepalive with interval:\", intervalMs, \"ms\");\n\n    this.keepaliveInterval = window.setInterval(async () => {\n      try {\n        if (this.streamId) {\n          await this.client.renewLease(this.streamId);\n          this.logger.debug(\"Lease renewed\");\n        }\n      } catch (error) {\n        this.logger.error(\"Keepalive failed:\", error);\n        const keepaliveError = new Error(\n          `Keepalive failed: ${error instanceof Error ? error.message : String(error)}`,\n        );\n        await this.handleFatalError(keepaliveError);\n      }\n    }, intervalMs);\n  }\n\n  /**\n   * Set up WebSocket connection with error handling\n   */\n  private setupWebSocket(streamId: string): void {\n    this.logger.debug(\"Connecting WebSocket for stream:\", streamId);\n    this.webSocket = this.client.connectWebSocket(streamId);\n\n    this.webSocket.onopen = () => {\n      this.logger.debug(\"WebSocket connected\");\n      if (this.webSocket) {\n        this.webSocket.send(JSON.stringify({ api_key: this.config.apiKey }));\n      }\n    };\n\n    this.webSocket.onmessage = (event) => {\n      try {\n        const result: StreamInferenceResult = JSON.parse(event.data);\n        this.config.onResult(result);\n      } catch (error) {\n        const parseError = new Error(\n          `Failed to parse WebSocket message: ${error instanceof Error ? error.message : String(error)}`,\n        );\n        this.handleNonFatalError(parseError);\n      }\n    };\n\n    this.webSocket.onerror = () => {\n      this.logger.error(\"WebSocket error occurred\");\n      const error = new Error(\"WebSocket error occurred\");\n      this.handleFatalError(error);\n    };\n\n    this.webSocket.onclose = (event) => {\n      if (this.isRunning) {\n        if (event.code === 1008) {\n          this.logger.error(\"WebSocket authentication failed\");\n          const error = new Error(\n            \"WebSocket authentication failed: Invalid or revoked API key\",\n          );\n          this.handleFatalError(error);\n        } else {\n          this.logger.warn(\"WebSocket closed unexpectedly:\", event.code);\n          const error = new Error(\"WebSocket closed unexpectedly\");\n          this.handleFatalError(error);\n        }\n      } else {\n        this.logger.debug(\"WebSocket closed\");\n      }\n    };\n  }\n\n  /**\n   * Handle non-fatal errors (report but don't stop stream)\n   */\n  private handleNonFatalError(error: Error): void {\n    this.logger.warn(\"Non-fatal error:\", error.message);\n    if (this.config.onError) {\n      this.config.onError(error);\n    }\n  }\n\n  /**\n   * Handle fatal errors (stop stream and report)\n   */\n  private async handleFatalError(error: unknown): Promise<void> {\n    this.logger.error(\"Fatal error:\", error);\n    await this.cleanup();\n    this.isRunning = false;\n\n    const normalizedError =\n      error instanceof Error ? error : new Error(String(error));\n\n    if (this.config.onError) {\n      this.config.onError(normalizedError);\n    }\n  }\n\n  /**\n   * Update the prompt/task while stream is running\n   */\n  async updatePrompt(prompt: string): Promise<void> {\n    if (!this.isRunning || !this.streamId) {\n      throw new Error(\"Vision stream not running\");\n    }\n\n    if (!prompt || typeof prompt !== \"string\") {\n      throw new ValidationError(\"prompt must be a non-empty string\");\n    }\n\n    this.logger.debug(\"Updating prompt\");\n    await this.client.updatePrompt(this.streamId, prompt);\n    this.logger.info(\"Prompt updated\");\n  }\n\n  /**\n   * Stop the vision stream and clean up resources\n   */\n  async stop(): Promise<void> {\n    this.logger.info(\"Stopping stream\");\n    await this.cleanup();\n    this.isRunning = false;\n  }\n\n  /**\n   * Get the current stream ID\n   */\n  getStreamId(): string | null {\n    return this.streamId;\n  }\n\n  /**\n   * Get the media stream (for displaying video preview)\n   */\n  getMediaStream(): MediaStream | null {\n    return this.mediaStream;\n  }\n\n  /**\n   * Check if the stream is running\n   */\n  isActive(): boolean {\n    return this.isRunning;\n  }\n\n  private async cleanup(): Promise<void> {\n    this.logger.debug(\"Cleaning up resources\");\n\n    if (this.keepaliveInterval) {\n      window.clearInterval(this.keepaliveInterval);\n      this.keepaliveInterval = null;\n    }\n\n    if (this.webSocket) {\n      this.webSocket.close();\n      this.webSocket = null;\n    }\n\n    if (this.peerConnection) {\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n\n    if (this.mediaStream) {\n      this.mediaStream.getTracks().forEach((track) => track.stop());\n      this.mediaStream = null;\n    }\n\n    if (this.canvasAnimationFrameId) {\n      cancelAnimationFrame(this.canvasAnimationFrameId);\n      this.canvasAnimationFrameId = null;\n    }\n\n    if (this.canvasElement) {\n      this.canvasElement.remove();\n      this.canvasElement = null;\n    }\n\n    if (this.videoElement) {\n      this.videoElement.pause();\n      URL.revokeObjectURL(this.videoElement.src);\n      this.videoElement.remove();\n      this.videoElement = null;\n    }\n\n    this.streamId = null;\n    this.logger.debug(\"Cleanup complete\");\n  }\n}\n"],
  "mappings": "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",
  "names": ["ValidationError", "_a"]
}
