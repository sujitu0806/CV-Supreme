<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Live Competition Mode — Shot Analysis</title>
  <style>
    :root {
      font-family: system-ui, -apple-system, sans-serif;
      line-height: 1.5;
      color: #1a1a1a;
      background: #f5f5f5;
    }
    body {
      max-width: 720px;
      margin: 0 auto;
      padding: 1.5rem;
    }
    h1 {
      font-size: 1.25rem;
      margin: 0 0 1rem;
    }
    .camera-wrap {
      margin-bottom: 1rem;
      border-radius: 8px;
      overflow: hidden;
      background: #111;
      aspect-ratio: 16/10;
      max-height: 280px;
    }
    .camera-wrap video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }
    .camera-wrap .placeholder {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #888;
      font-size: 0.9rem;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      margin-bottom: 1rem;
    }
    button {
      padding: 0.5rem 1rem;
      font-size: 0.9rem;
      cursor: pointer;
      border: 1px solid #ccc;
      border-radius: 6px;
      background: #fff;
    }
    button:hover {
      background: #f0f0f0;
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    #status {
      font-size: 0.875rem;
      color: #555;
    }
    .error-msg {
      font-size: 0.875rem;
      color: #c00;
      max-width: 480px;
      margin-top: 0.5rem;
    }
    .last-analysis {
      font-size: 0.8rem;
      color: #666;
      margin-top: 0.5rem;
    }
    .last-analysis code {
      background: #eee;
      padding: 0.1em 0.3em;
      border-radius: 3px;
    }
    .simple-test-label {
      font-size: 0.85rem;
      color: #555;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }
    .simple-test-label input { margin: 0; }
    .debug-panel {
      margin-top: 1.5rem;
      padding: 1rem;
      background: #fafafa;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
    }
    .debug-panel h2 { font-size: 1rem; margin: 0 0 0.5rem; }
    .debug-desc { font-size: 0.85rem; color: #666; margin: 0 0 0.5rem; }
    .debug-panel pre {
      font-size: 0.75rem;
      overflow: auto;
      max-height: 180px;
      margin: 0.5rem 0 0;
      padding: 0.5rem;
      background: #fff;
      border: 1px solid #eee;
      border-radius: 4px;
    }
    .debug-panel .ok { color: #060; }
    .debug-panel .fail { color: #c00; }
    .metadata-panel {
      margin-top: 1.5rem;
      padding: 1rem;
      background: #fff;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
    }
    .metadata-panel h2 {
      font-size: 1rem;
      margin: 0 0 0.75rem;
    }
    .metadata-grid {
      display: grid;
      gap: 0.5rem 1rem;
      font-size: 0.85rem;
    }
    .metadata-grid dt {
      font-weight: 600;
      color: #333;
    }
    .metadata-grid dd {
      margin: 0;
      color: #555;
    }
    .metadata-panel .none {
      color: #888;
      font-style: italic;
    }
    .metadata-panel pre {
      margin: 0.75rem 0 0;
      padding: 0.75rem;
      background: #f8f8f8;
      border-radius: 6px;
      font-size: 0.75rem;
      overflow: auto;
      max-height: 200px;
    }
    .shots-section {
      margin-top: 1.5rem;
    }
    .shots-section h2 {
      font-size: 1rem;
      margin: 0 0 0.5rem;
    }
    #shot-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    #shot-list li {
      padding: 0.75rem;
      margin-bottom: 0.5rem;
      background: #fff;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
      font-size: 0.8rem;
    }
    #shot-list li strong {
      display: block;
      margin-bottom: 0.25rem;
      color: #333;
    }
    #shot-list .meta {
      color: #666;
      margin-top: 0.25rem;
    }
    .export-hint {
      font-size: 0.8rem;
      color: #666;
      margin-top: 0.25rem;
    }
  </style>
</head>
<body>
  <h1>Live Competition Mode</h1>
  <p>Position the camera facing the opponent (or use it to see yourself for testing). Start to begin analyzing.</p>

  <div class="camera-wrap">
    <video id="camera-preview" autoplay playsinline muted></video>
    <div id="camera-placeholder" class="placeholder">Camera preview will appear when you Start</div>
  </div>

  <div class="controls">
    <button type="button" id="btn-start">Start</button>
    <button type="button" id="btn-stop" disabled>Stop</button>
    <button type="button" id="btn-export">Download copy</button>
    <label class="simple-test-label"><input type="checkbox" id="simple-test" /> Simple test (no JSON — see if Overshoot responds at all)</label>
    <span id="status">Stopped</span>
  </div>
  <div id="error-area" class="error-msg" style="display: none;"></div>
  <div id="last-analysis" class="last-analysis" style="display: none;"></div>

  <section class="debug-panel">
    <h2>Overshoot API debug</h2>
    <p class="debug-desc">Use this to verify the API is returning anything. Enable "Simple test" and Start — you should see results every ~1s and a short sentence describing the video.</p>
    <div id="debug-content">
      <p class="none">Start the stream to see API response count and last raw result.</p>
    </div>
  </section>

  <section class="metadata-panel">
    <h2>Extracted metadata (latest shot)</h2>
    <div id="metadata-display">
      <p class="none">No shots detected yet. Start the stream and hit the ball to see metadata here.</p>
    </div>
    <pre id="metadata-json" style="display: none;"></pre>
  </section>

  <section class="shots-section">
    <h2>Last 10 shots</h2>
    <ul id="shot-list"></ul>
  </section>
  <p class="export-hint">Each stream is auto-saved to <code>comp_mode/metadata_exports/session_&lt;id&gt;.json</code>. Use "Download copy" to save a JSON to your device.</p>

  <script type="module">
    import { start, stop, shots, onShot, getPreviewStream } from '/src/main.js';

    const MAX_SHOTS_DISPLAY = 10;
    const statusEl = document.getElementById('status');
    const errorArea = document.getElementById('error-area');
    const startBtn = document.getElementById('btn-start');
    const stopBtn = document.getElementById('btn-stop');
    const exportBtn = document.getElementById('btn-export');
    const listEl = document.getElementById('shot-list');
    const videoEl = document.getElementById('camera-preview');
    const placeholderEl = document.getElementById('camera-placeholder');
    const metadataDisplay = document.getElementById('metadata-display');
    const metadataJson = document.getElementById('metadata-json');
    const lastAnalysisEl = document.getElementById('last-analysis');
    const debugContent = document.getElementById('debug-content');
    const simpleTestCheckbox = document.getElementById('simple-test');

    /** When we show camera from preview-only (no SDK), we keep this to stop tracks on Stop. */
    let previewOnlyStream = null;
    /** Current session id for auto-save to metadata_exports. */
    let currentSessionId = null;

    function setStatus(text) {
      statusEl.textContent = text;
    }

    function showError(msg) {
      errorArea.textContent = msg || '';
      errorArea.style.display = msg ? 'block' : 'none';
    }

    function showLastAnalysis(data) {
      if (!lastAnalysisEl) return;
      const shot = data?.shot_detected === true;
      lastAnalysisEl.innerHTML = shot
        ? 'Last result: <strong>shot detected</strong>'
        : 'Last result: <code>no shot</code> in this window';
      lastAnalysisEl.style.display = 'block';
    }

    function showDebugResult(info) {
      if (!debugContent) return;
      const rawPreview = info.raw.length > 400 ? info.raw.slice(0, 400) + '…' : info.raw;
      const okClass = info.ok ? 'ok' : 'fail';
      let html = `<p><strong>Results received:</strong> ${info.count}</p>`;
      html += `<p><strong>Last response</strong> — <span class="${okClass}">ok: ${info.ok}</span>`;
      if (info.error) html += ` <span class="fail">error: ${escapeHtml(info.error)}</span>`;
      html += '</p>';
      if (info.parseError) html += `<p class="fail">Parse error: ${escapeHtml(info.parseError)}</p>`;
      if (info.parsed != null) html += '<p>Parsed: <pre>' + escapeHtml(JSON.stringify(info.parsed, null, 2).slice(0, 800)) + (JSON.stringify(info.parsed).length > 800 ? '…' : '') + '</pre></p>';
      html += '<p>Raw result (last):</p><pre>' + escapeHtml(rawPreview || '(empty)') + '</pre>';
      debugContent.innerHTML = html;
    }
    function escapeHtml(s) {
      const div = document.createElement('div');
      div.textContent = s;
      return div.innerHTML;
    }

    async function apiSessionStart() {
      const res = await fetch('/api/session/start', { method: 'POST' });
      if (!res.ok) return null;
      const { sessionId } = await res.json();
      return sessionId;
    }

    async function apiSessionAppend(sessionId, shot) {
      if (!sessionId) return;
      try {
        await fetch('/api/session/append', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ sessionId, shot }),
        });
      } catch (e) {
        console.warn('Session append failed:', e);
      }
    }

    async function apiSessionEnd(sessionId, shotsList) {
      if (!sessionId) return;
      try {
        await fetch('/api/session/end', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ sessionId, shots: shotsList }),
        });
      } catch (e) {
        console.warn('Session end failed:', e);
      }
    }

    function showCamera(stream, isPreviewOnly = false) {
      if (!stream) return;
      if (previewOnlyStream) {
        previewOnlyStream.getTracks().forEach((t) => t.stop());
        previewOnlyStream = null;
      }
      placeholderEl.style.display = 'none';
      videoEl.style.display = 'block';
      videoEl.srcObject = stream;
      videoEl.play().catch(() => {});
      if (isPreviewOnly) previewOnlyStream = stream;
    }

    function hideCamera() {
      if (previewOnlyStream) {
        previewOnlyStream.getTracks().forEach((t) => t.stop());
        previewOnlyStream = null;
      }
      videoEl.srcObject = null;
      videoEl.style.display = 'none';
      placeholderEl.style.display = 'flex';
    }

    function renderMetadata(shot) {
      if (!shot) {
        metadataDisplay.innerHTML = '<p class="none">No shots detected yet. Start the stream and hit the ball to see metadata here.</p>';
        metadataJson.style.display = 'none';
        return;
      }
      const s = shot.serve_type?.value ?? '—';
      const sp = (shot.serve_type?.confidence ?? 0).toFixed(2);
      const spin = shot.spin_type?.value ?? '—';
      const spConf = (shot.spin_type?.confidence ?? 0).toFixed(2);
      const zone = shot.ball_landing?.zone ?? '—';
      const angle = shot.ball_landing?.angle ?? '—';
      const landConf = (shot.ball_landing?.confidence ?? 0).toFixed(2);
      const dist = shot.opponent_position?.distance_from_table ?? '—';
      const lat = shot.opponent_position?.lateral_position ?? '—';
      const posConf = (shot.opponent_position?.confidence ?? 0).toFixed(2);
      const sh = shot.joint_angles?.shoulder ?? '—';
      const el = shot.joint_angles?.elbow ?? '—';
      const wr = shot.joint_angles?.wrist ?? '—';
      const jointConf = (shot.joint_angles?.confidence ?? 0).toFixed(2);
      metadataDisplay.innerHTML = `
        <dl class="metadata-grid">
          <dt>Timestamp</dt><dd>${shot.shot_timestamp}</dd>
          <dt>Serve type</dt><dd>${s} (${sp})</dd>
          <dt>Spin type</dt><dd>${spin} (${spConf})</dd>
          <dt>Ball landing zone</dt><dd>${zone}</dd>
          <dt>Ball trajectory</dt><dd>${angle}</dd>
          <dt>Landing confidence</dt><dd>${landConf}</dd>
          <dt>Distance from table</dt><dd>${dist}</dd>
          <dt>Lateral position</dt><dd>${lat}</dd>
          <dt>Position confidence</dt><dd>${posConf}</dd>
          <dt>Shoulder</dt><dd>${sh}</dd>
          <dt>Elbow</dt><dd>${el}</dd>
          <dt>Wrist</dt><dd>${wr}</dd>
          <dt>Joint confidence</dt><dd>${jointConf}</dd>
        </dl>
      `;
      metadataJson.textContent = JSON.stringify(shot, null, 2);
      metadataJson.style.display = 'block';
    }

    function renderShots() {
      const recent = shots.slice(-MAX_SHOTS_DISPLAY).reverse();
      listEl.innerHTML = recent.map((s) => {
        const serve = s.serve_type?.value ?? '—';
        const spin = s.spin_type?.value ?? '—';
        const zone = s.ball_landing?.zone ?? '—';
        const pos = [s.opponent_position?.distance_from_table, s.opponent_position?.lateral_position].filter(Boolean).join(' / ') || '—';
        return `<li>
          <strong>${s.shot_timestamp}</strong>
          Serve: ${serve} · Spin: ${spin} · Zone: ${zone} · Pos: ${pos}
          <div class="meta">Confidence: spin ${(s.spin_type?.confidence ?? 0).toFixed(2)} · landing ${(s.ball_landing?.confidence ?? 0).toFixed(2)}</div>
        </li>`;
      }).join('');
      const latest = shots[shots.length - 1];
      renderMetadata(latest);
    }

    onShot((observation) => {
      renderShots();
      if (currentSessionId) apiSessionAppend(currentSessionId, observation);
    });

    startBtn.addEventListener('click', async () => {
      startBtn.disabled = true;
      showError('');
      setStatus('Starting…');
      let previewStream = null;
      try {
        previewStream = await getPreviewStream();
        showCamera(previewStream, true);
        setStatus('Connecting to analysis…');
        try {
          currentSessionId = await apiSessionStart();
        } catch (_) {
          currentSessionId = null;
        }
        lastAnalysisEl.style.display = 'none';
        debugContent.innerHTML = '<p>Connecting…</p>';
      } catch (e) {
        const msg = e?.message ?? String(e);
        showError('Camera: ' + msg);
        setStatus('Camera error');
        startBtn.disabled = false;
        return;
      }
      try {
        await start({
          onStatus(s) {
            if (s === 'running') {
              stopBtn.disabled = false;
              setStatus('Running — analyzing…');
            } else if (s === 'error') {
              startBtn.disabled = false;
              setStatus('Analysis failed (camera stays on)');
            } else if (s === 'already_running') {
              startBtn.disabled = true;
              stopBtn.disabled = false;
              setStatus('Running');
            }
          },
          onError(msg) {
            showError(msg);
          },
          onRawResult(data) {
            showLastAnalysis(data);
          },
          onDebugResult(info) {
            showDebugResult(info);
          },
          useSimpleTest: !!simpleTestCheckbox?.checked,
          onStream(stream) {
            if (previewStream) {
              previewStream.getTracks().forEach((t) => t.stop());
              previewStream = null;
            }
            showCamera(stream, false);
          },
        });
      } catch (e) {
        const msg = e?.message ?? String(e);
        showError(msg);
        setStatus('Analysis failed (camera stays on)');
        startBtn.disabled = false;
      }
    });

    stopBtn.addEventListener('click', async () => {
      stopBtn.disabled = true;
      setStatus('Stopping…');
      showError('');
      if (currentSessionId) {
        await apiSessionEnd(currentSessionId, [...shots]);
        currentSessionId = null;
      }
      lastAnalysisEl.style.display = 'none';
      debugContent.innerHTML = '<p class="none">Start the stream to see API response count and last raw result.</p>';
      hideCamera();
      await stop({
        onStatus(s) {
          if (s === 'stopped') {
            startBtn.disabled = false;
            setStatus('Stopped');
          }
        },
      });
    });

    exportBtn.addEventListener('click', () => {
      const payload = { exportedAt: new Date().toISOString(), shots };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const now = new Date();
      const name = `shots_${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}-${String(now.getSeconds()).padStart(2, '0')}.json`;
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = name;
      a.click();
      URL.revokeObjectURL(a.href);
    });
  </script>
</body>
</html>
